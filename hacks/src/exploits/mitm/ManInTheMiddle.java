package exploits.mitm;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public abstract class ManInTheMiddle {
	
	protected Logger logger = Logger.getLogger(ManInTheMiddle.class.getName());
	
	protected List<String> gatewayIPs = null;
	protected List<String> victimIPs = null;
	
	protected boolean debugOutputToConsole = true;
	protected Process process;
	protected BufferedReader pReader;
	protected BufferedWriter pWriter;
	
	/**
	 * Initalizes the level of the logger, leaving other tasks for
	 * constructors of subclasses
	 */
	public ManInTheMiddle() {
		logger.setLevel(Level.ALL);
	}
	
	/**
	 * @param gatewayIPs
	 * 		A List containing the IP addresses of the gateway(s)
	 * @param victimIPs
	 * 		A List containing the IP addresses of the victim(s)
	 */
	public ManInTheMiddle(List<String> gatewayIPs, List<String> victimIPs) {
		this.gatewayIPs = gatewayIPs;
		this.victimIPs = victimIPs;
	}
	
	public List<String> getGatewayIPs() {
		return gatewayIPs;
	}

	public void setGatewayIPs(List<String> gatewayIPs) {
		this.gatewayIPs = gatewayIPs;
	}

	public List<String> getVictimIPs() {
		return victimIPs;
	}

	public void setVictimIPs(List<String> victimIPs) {
		this.victimIPs = victimIPs;
	}
	
	public boolean isDebugOutputToConsole() {
		return debugOutputToConsole;
	}

	public void setDebugOutputToConsole(boolean debugOutputToConsole) {
		this.debugOutputToConsole = debugOutputToConsole;
	}

	/**
	 * Separates a string into parts at its spaces, so that it can be processed by
	 * the process class
	 * 
	 * @param str
	 * 		The String to convert to a List
	 * @return
	 * 		The list containing the parts of the string
	 */
	private static List<String> separateSpaces(String str) {
		return Arrays.asList(str.split(" "));
	}
	
	/**
	 * Read the current output from the process for a specified amount of time. Blocks
	 * until input is received or until the time finishes.
	 * 
	 * @param milliseconds
	 * 				The number of milliseconds to search
	 * @return all of the available unread text from the command line process
	 * @throws IOException
	 */
	String readProcessOutput(int milliseconds) throws IOException {
		String result = "";
		int tryCount = 0;
		// try reading results from the process up to the number of milliseconds
		while (tryCount < milliseconds / 100) {
			// continue reading as long as there are lines of text to read
			while (pReader.ready()) {
				result += pReader.readLine() + "\n";
			}
			if (result.length() == 0) {
				// no results read, so wait 0.5 seconds and try again
				try {
					Thread.sleep(100);
				} catch (InterruptedException ex) {
					logger.log(Level.WARNING, "", ex);
				}
				tryCount++;
			} else {
				// got a result, so stop reading (no more waiting, no more
				// retries)
				break;
			}
		}
		return result;
	}
	
	/**
	 * Gets output from the process and blocks for a specified amount of time or until
	 * the search string is found
	 * 
	 * @param search
	 * 		The string to search for in the output
	 * @param milliseconds
	 * 		The number of milliseconds to search for the string until
	 * 		giving up
	 * @return 
	 * 		The output if the search string was found
	 * 		null if the string was not found after the time limit has expired
	 * @throws IOException
	 * 		If trouble was encountered when reading the ouput
	 */
	MatchProcessOutput readProcessOutput(String search, int milliseconds) throws IOException {
		String result = "";
		int tryCount = 0;
		// try to read a result for the specified number of milliseconds
		while (tryCount < milliseconds / 100) {
			result += readProcessOutput(100);
			// if the result does not contain the string to search for,
			// sleep for 0.1 seconds then and try again
			if (!result.contains(search)) {
				try {
					Thread.sleep(100);
				} catch (InterruptedException ex) {
					logger.log(Level.WARNING, "", ex);
				}
			} else {
				// if the search string is found, exit the loop and return
				return new MatchProcessOutput(search, result, true);
			}
		}
		return new MatchProcessOutput(search, result, false);
	}
	
	/**
	 * Send a command to the process
	 * @param command the text to send to the process, 
	 * 					note that a '\n' (e.g. [enter]) character 
	 * 					will be appended to the command if one is not provided
	 * @throws IOException
	 */
	void sendProcessInput(String command) throws IOException {
		if (debugOutputToConsole) {
			System.out.println("Send command>" + command);
		}
		if (!command.endsWith("\n")) {
			command += "\n";
		}
		pWriter.write(command);
		pWriter.flush();
	}
	
	/**
	 * Initiate the Man-in-the-Middle attack
	 * @throws IOException
	 * 		If the process cannot be built or an error occurs 
	 */
	public void run() throws IOException {
		setup();
		runAttack();
		cleanup();
	}
	
	/**
	 * Sets up the process and its I/O streams
	 * @throws IOException
	 * 		If the process cannot be built
	 */
	protected void setup() throws IOException {
		// create a process to interact with via command line
		ProcessBuilder builder = new ProcessBuilder("/bin/sh");
		// redirect the process error stream to the output stream
		builder.redirectErrorStream(true);
		// start the process
		process = builder.start();
		// create a buffered reader to get text results from the process
		pReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
		// create a buffered writer to send text commands to the process
		pWriter = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
	}
	
	/**
	 * Starts the specific attack
	 * @throws IOException
	 * 		see the overriden method in the specific subclass
	 */
	protected abstract void runAttack() throws IOException;
	
	/**
	 * Closes the streams and stops the process
	 */
	protected void cleanup() {
		try {
			pReader.close();
		} catch (IOException ex) {
			logger.log(Level.WARNING, "", ex);
		}
		try {
			pWriter.close();
		} catch (IOException ex) {
			logger.log(Level.WARNING, "", ex);
		}
		process.destroy();
	}
	
	class MatchProcessOutput {
		private String searchStr;
		private String output;
		private boolean foundStr;
		
		MatchProcessOutput(String searchStr, String output, boolean foundStr) {
			this.searchStr = searchStr;
			this.output = output;
			this.foundStr = foundStr;
		}
		
		String getSearchStr() {
			return searchStr;
		}
		
		String getOutput() {
			return output;
		}
		
		boolean hasFoundStr() {
			return foundStr;
		}
	}
	
}
